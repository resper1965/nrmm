# üõ°Ô∏è M√ìDULO AVAN√áADO DE VULNERABILIDADES - m.RMM
# An√°lise t√©cnica e implementa√ß√£o completa

"""
VULNERABILITY MANAGEMENT MODULE - DEEP DIVE
===========================================

Este m√≥dulo implementa um sistema completo de gerenciamento de vulnerabilidades
para o m.RMM, integrando com m√∫ltiplos scanners e fornecendo an√°lise avan√ßada.
"""

# ====================================================================
# 1. MODELS AVAN√áADOS - Django
# ====================================================================

from django.db import models
from django.contrib.auth import get_user_model
from django.core.validators import URLValidator
from django.utils import timezone
from datetime import timedelta
import json
import requests
from typing import Dict, List, Optional

User = get_user_model()


class VulnerabilityFramework(models.Model):
    """Frameworks de classifica√ß√£o de vulnerabilidades (CVSS, OWASP, etc.)"""
    name = models.CharField(max_length=50, unique=True)  # CVSS3.1, OWASP Top 10
    version = models.CharField(max_length=20)
    description = models.TextField()
    scoring_matrix = models.JSONField(default=dict)  # Matriz de pontua√ß√£o
    is_active = models.BooleanField(default=True)
    
    def __str__(self):
        return f"{self.name} v{self.version}"


class VulnerabilityScanner(models.Model):
    """Configura√ß√£o avan√ßada para scanners externos"""
    
    SCANNER_TYPES = [
        ('nessus', 'Tenable Nessus'),
        ('openvas', 'OpenVAS/GVM'),
        ('qualys', 'Qualys VMDR'),
        ('rapid7', 'Rapid7 InsightVM'),
        ('nuclei', 'Nuclei (YAML-based)'),
        ('wazuh', 'Wazuh Vulnerability Detector'),
        ('trivy', 'Aqua Trivy'),
        ('grype', 'Anchore Grype'),
        ('custom', 'Custom Scanner'),
    ]
    
    name = models.CharField(max_length=100)
    scanner_type = models.CharField(max_length=50, choices=SCANNER_TYPES)
    api_url = models.URLField(validators=[URLValidator()])
    api_key = models.CharField(max_length=500, blank=True)  # Maior para JWT
    api_secret = models.CharField(max_length=500, blank=True)
    
    # Configura√ß√µes avan√ßadas
    max_concurrent_scans = models.IntegerField(default=5)
    scan_timeout = models.IntegerField(default=3600, help_text="Timeout em segundos")
    retry_attempts = models.IntegerField(default=3)
    scan_profiles = models.JSONField(default=list)  # Perfis de scan dispon√≠veis
    
    # Configura√ß√µes de rede
    proxy_url = models.URLField(blank=True)
    use_ssl_verification = models.BooleanField(default=True)
    custom_headers = models.JSONField(default=dict)
    
    # Schedule e automa√ß√£o
    default_scan_interval = models.IntegerField(default=86400 * 7)  # 7 dias
    auto_start_scans = models.BooleanField(default=False)
    scan_on_new_agent = models.BooleanField(default=True)
    
    # Filtros e exclus√µes
    excluded_ports = models.CharField(max_length=500, blank=True)
    excluded_hosts = models.TextField(blank=True)
    scan_policies = models.JSONField(default=dict)
    
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    last_health_check = models.DateTimeField(null=True, blank=True)
    health_status = models.CharField(max_length=20, choices=[
        ('healthy', 'Healthy'),
        ('warning', 'Warning'),
        ('error', 'Error'),
        ('unknown', 'Unknown'),
    ], default='unknown')
    
    class Meta:
        ordering = ['name']
    
    def __str__(self):
        return f"{self.name} ({self.get_scanner_type_display()})"
    
    def test_connection(self) -> Dict:
        """Testa conectividade com o scanner"""
        try:
            # Implementa√ß√£o espec√≠fica por tipo de scanner
            if self.scanner_type == 'nessus':
                return self._test_nessus_connection()
            elif self.scanner_type == 'openvas':
                return self._test_openvas_connection()
            # ... outros scanners
            
        except Exception as e:
            return {
                'status': 'error',
                'message': str(e),
                'timestamp': timezone.now()
            }
    
    def _test_nessus_connection(self) -> Dict:
        """Testa conex√£o espec√≠fica do Nessus"""
        headers = {
            'X-ApiKeys': f'accessKey={self.api_key}; secretKey={self.api_secret}',
            'Content-Type': 'application/json'
        }
        
        response = requests.get(
            f"{self.api_url}/server/status",
            headers=headers,
            timeout=10,
            verify=self.use_ssl_verification
        )
        
        if response.status_code == 200:
            return {
                'status': 'healthy',
                'message': 'Connection successful',
                'scanner_info': response.json(),
                'timestamp': timezone.now()
            }
        else:
            return {
                'status': 'error',
                'message': f'HTTP {response.status_code}: {response.text}',
                'timestamp': timezone.now()
            }


class VulnerabilityScanProfile(models.Model):
    """Perfis de scan personaliz√°veis"""
    name = models.CharField(max_length=100)
    scanner = models.ForeignKey(VulnerabilityScanner, on_delete=models.CASCADE)
    description = models.TextField()
    
    # Configura√ß√µes do scan
    scan_type = models.CharField(max_length=50, choices=[
        ('full', 'Full Network Scan'),
        ('quick', 'Quick Scan'),
        ('custom', 'Custom Scan'),
        ('compliance', 'Compliance Scan'),
        ('web_app', 'Web Application Scan'),
        ('database', 'Database Scan'),
    ])
    
    # Par√¢metros de scan
    target_ports = models.TextField(default="1-65535")
    scan_intensity = models.CharField(max_length=20, choices=[
        ('light', 'Light'),
        ('normal', 'Normal'),
        ('aggressive', 'Aggressive'),
    ], default='normal')
    
    # Configura√ß√µes avan√ßadas
    enable_safe_checks = models.BooleanField(default=True)
    enable_web_app_tests = models.BooleanField(default=False)
    enable_dos_tests = models.BooleanField(default=False)
    max_scan_duration = models.IntegerField(default=7200)  # 2 horas
    
    # Plugin/Script configuration
    enabled_plugins = models.JSONField(default=list)
    disabled_plugins = models.JSONField(default=list)
    custom_scripts = models.JSONField(default=list)
    
    # Compliance frameworks
    compliance_frameworks = models.ManyToManyField(
        'compliance.ComplianceFramework', 
        blank=True
    )
    
    is_default = models.BooleanField(default=False)
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        unique_together = ['scanner', 'name']
    
    def __str__(self):
        return f"{self.scanner.name} - {self.name}"


class VulnerabilityScan(models.Model):
    """Inst√¢ncias de scan de vulnerabilidades"""
    
    SCAN_STATUS = [
        ('queued', 'Queued'),
        ('initializing', 'Initializing'),
        ('running', 'Running'),
        ('paused', 'Paused'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
        ('cancelled', 'Cancelled'),
        ('timeout', 'Timeout'),
    ]
    
    scanner = models.ForeignKey(VulnerabilityScanner, on_delete=models.CASCADE)
    profile = models.ForeignKey(VulnerabilityScanProfile, on_delete=models.SET_NULL, null=True)
    agent = models.ForeignKey('agents.Agent', on_delete=models.CASCADE)
    
    # Identificadores externos
    external_scan_id = models.CharField(max_length=100, blank=True)
    scan_uuid = models.UUIDField(unique=True, auto_created=True)
    
    # Status e timing
    status = models.CharField(max_length=20, choices=SCAN_STATUS, default='queued')
    progress_percentage = models.IntegerField(default=0)
    
    # Timestamps
    queued_at = models.DateTimeField(auto_now_add=True)
    started_at = models.DateTimeField(null=True, blank=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    estimated_completion = models.DateTimeField(null=True, blank=True)
    
    # Resultados estat√≠sticos
    total_vulnerabilities = models.IntegerField(default=0)
    critical_count = models.IntegerField(default=0)
    high_count = models.IntegerField(default=0)
    medium_count = models.IntegerField(default=0)
    low_count = models.IntegerField(default=0)
    info_count = models.IntegerField(default=0)
    
    # M√©tricas de scan
    hosts_scanned = models.IntegerField(default=0)
    ports_scanned = models.IntegerField(default=0)
    services_identified = models.IntegerField(default=0)
    
    # Configura√ß√µes do scan
    scan_config = models.JSONField(default=dict)
    target_specification = models.TextField()  # IPs, ranges, hostnames
    excluded_targets = models.TextField(blank=True)
    
    # Logs e debugging
    scan_logs = models.TextField(blank=True)
    error_messages = models.TextField(blank=True)
    debug_info = models.JSONField(default=dict)
    
    # Trigger information
    triggered_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True)
    trigger_type = models.CharField(max_length=20, choices=[
        ('manual', 'Manual'),
        ('scheduled', 'Scheduled'),
        ('event', 'Event-driven'),
        ('api', 'API Call'),
        ('auto', 'Automatic'),
    ], default='manual')
    
    # Relacionamentos
    parent_scan = models.ForeignKey('self', on_delete=models.CASCADE, null=True, blank=True)
    organization = models.ForeignKey('clients.Client', on_delete=models.CASCADE)
    
    class Meta:
        ordering = ['-queued_at']
        indexes = [
            models.Index(fields=['status', 'scanner']),
            models.Index(fields=['agent', 'completed_at']),
            models.Index(fields=['organization', 'status']),
        ]
    
    def __str__(self):
        return f"{self.agent.hostname} - {self.scanner.name} ({self.status})"
    
    @property
    def duration(self) -> Optional[timedelta]:
        """Dura√ß√£o do scan"""
        if self.started_at and self.completed_at:
            return self.completed_at - self.started_at
        elif self.started_at:
            return timezone.now() - self.started_at
        return None
    
    @property
    def risk_score(self) -> float:
        """Calcula score de risco baseado nas vulnerabilidades"""
        if self.total_vulnerabilities == 0:
            return 0.0
        
        # Peso por severidade
        weights = {
            'critical': 10.0,
            'high': 6.0,
            'medium': 3.0,
            'low': 1.0,
            'info': 0.1
        }
        
        score = (
            self.critical_count * weights['critical'] +
            self.high_count * weights['high'] +
            self.medium_count * weights['medium'] +
            self.low_count * weights['low'] +
            self.info_count * weights['info']
        )
        
        # Normalizar para 0-100
        max_possible = self.total_vulnerabilities * weights['critical']
        return min(100.0, (score / max_possible) * 100) if max_possible > 0 else 0.0
    
    def start_scan(self) -> bool:
        """Inicia o scan no scanner externo"""
        try:
            if self.scanner.scanner_type == 'nessus':
                return self._start_nessus_scan()
            elif self.scanner.scanner_type == 'openvas':
                return self._start_openvas_scan()
            # ... outros scanners
            
        except Exception as e:
            self.status = 'failed'
            self.error_messages = str(e)
            self.save()
            return False
    
    def _start_nessus_scan(self) -> bool:
        """Inicia scan espec√≠fico do Nessus"""
        # Implementa√ß√£o espec√≠fica do Nessus
        pass


class Vulnerability(models.Model):
    """Vulnerabilidades individuais encontradas"""
    
    SEVERITY_LEVELS = [
        ('critical', 'Critical'),
        ('high', 'High'),
        ('medium', 'Medium'),
        ('low', 'Low'),
        ('info', 'Informational'),
    ]
    
    STATUS_CHOICES = [
        ('open', 'Open'),
        ('fixed', 'Fixed'),
        ('accepted_risk', 'Accepted Risk'),
        ('false_positive', 'False Positive'),
        ('under_review', 'Under Review'),
        ('wont_fix', 'Won\'t Fix'),
    ]
    
    # Relacionamentos
    scan = models.ForeignKey(
        VulnerabilityScan, 
        on_delete=models.CASCADE, 
        related_name='vulnerabilities'
    )
    agent = models.ForeignKey('agents.Agent', on_delete=models.CASCADE)
    organization = models.ForeignKey('clients.Client', on_delete=models.CASCADE)
    
    # Identifica√ß√£o da vulnerabilidade
    cve_id = models.CharField(max_length=20, blank=True, db_index=True)
    cwe_id = models.CharField(max_length=20, blank=True)  # Common Weakness Enumeration
    plugin_id = models.CharField(max_length=50, blank=True)  # Scanner plugin ID
    external_id = models.CharField(max_length=100, blank=True)
    
    # Informa√ß√µes b√°sicas
    title = models.CharField(max_length=500)
    description = models.TextField()
    synopsis = models.TextField(blank=True)  # Resumo t√©cnico
    
    # Classifica√ß√£o e scoring
    severity = models.CharField(max_length=20, choices=SEVERITY_LEVELS)
    cvss_score = models.FloatField(null=True, blank=True)
    cvss_vector = models.CharField(max_length=200, blank=True)
    cvss_version = models.CharField(max_length=10, default='3.1')
    
    # Scoring customizado
    risk_score = models.FloatField(default=0.0)  # Score interno de risco
    business_impact = models.CharField(max_length=20, choices=[
        ('low', 'Low'),
        ('medium', 'Medium'),
        ('high', 'High'),
        ('critical', 'Critical'),
    ], default='medium')
    
    # Detalhes t√©cnicos
    affected_software = models.CharField(max_length=255, blank=True)
    affected_version = models.CharField(max_length=100, blank=True)
    installed_version = models.CharField(max_length=100, blank=True)
    
    # Localiza√ß√£o
    host = models.GenericIPAddressField(null=True, blank=True)
    port = models.IntegerField(null=True, blank=True)
    protocol = models.CharField(max_length=10, choices=[
        ('tcp', 'TCP'),
        ('udp', 'UDP'),
        ('icmp', 'ICMP'),
    ], blank=True)
    service = models.CharField(max_length=100, blank=True)
    
    # URL para vulnerabilidades web
    url = models.URLField(blank=True)
    http_method = models.CharField(max_length=10, blank=True)
    request_data = models.TextField(blank=True)
    
    # Evid√™ncias e proof of concept
    evidence = models.TextField(blank=True)
    proof_of_concept = models.TextField(blank=True)
    scan_output = models.TextField(blank=True)
    
    # Remediation
    solution = models.TextField(blank=True)
    workaround = models.TextField(blank=True)
    patch_available = models.BooleanField(default=False)
    patch_url = models.URLField(blank=True)
    
    # Status e lifecycle
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='open')
    verified = models.BooleanField(default=False)
    exploitable = models.BooleanField(default=False)
    
    # Timestamps
    first_seen = models.DateTimeField(auto_now_add=True)
    last_seen = models.DateTimeField(auto_now=True)
    resolved_at = models.DateTimeField(null=True, blank=True)
    due_date = models.DateTimeField(null=True, blank=True)
    
    # Tracking
    assigned_to = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True)
    resolution_notes = models.TextField(blank=True)
    
    # Referencias externas
    references = models.JSONField(default=list)  # URLs, advisories, etc.
    tags = models.JSONField(default=list)  # Tags customiz√°veis
    
    # Compliance mapping
    compliance_mappings = models.JSONField(default=dict)  # Mapping para frameworks
    
    class Meta:
        ordering = ['-cvss_score', '-first_seen']
        indexes = [
            models.Index(fields=['cve_id']),
            models.Index(fields=['severity', 'status']),
            models.Index(fields=['agent', 'status']),
            models.Index(fields=['organization', 'severity']),
            models.Index(fields=['first_seen', 'status']),
        ]
        unique_together = ['scan', 'cve_id', 'host', 'port', 'url']
    
    def __str__(self):
        return f"{self.cve_id or self.title[:50]} - {self.get_severity_display()}"
    
    @property
    def age_days(self) -> int:
        """Idade da vulnerabilidade em dias"""
        return (timezone.now() - self.first_seen).days
    
    @property
    def is_overdue(self) -> bool:
        """Verifica se est√° atrasada baseado na due_date"""
        return self.due_date and timezone.now() > self.due_date
    
    def calculate_sla_due_date(self) -> timezone.datetime:
        """Calcula data limite baseada na severidade"""
        sla_days = {
            'critical': 1,
            'high': 7,
            'medium': 30,
            'low': 90,
            'info': 180
        }
        
        days = sla_days.get(self.severity, 90)
        return self.first_seen + timedelta(days=days)
    
    def set_status(self, new_status: str, user: User, notes: str = ""):
        """Atualiza status com auditoria"""
        old_status = self.status
        self.status = new_status
        
        if new_status in ['fixed', 'false_positive', 'wont_fix']:
            self.resolved_at = timezone.now()
        
        self.resolution_notes = notes
        self.save()
        
        # Criar log de auditoria
        VulnerabilityStatusChange.objects.create(
            vulnerability=self,
            old_status=old_status,
            new_status=new_status,
            changed_by=user,
            notes=notes
        )


class VulnerabilityStatusChange(models.Model):
    """Hist√≥rico de mudan√ßas de status das vulnerabilidades"""
    vulnerability = models.ForeignKey(
        Vulnerability, 
        on_delete=models.CASCADE,
        related_name='status_changes'
    )
    old_status = models.CharField(max_length=20)
    new_status = models.CharField(max_length=20)
    changed_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True)
    changed_at = models.DateTimeField(auto_now_add=True)
    notes = models.TextField(blank=True)
    
    class Meta:
        ordering = ['-changed_at']


class VulnerabilityExclusion(models.Model):
    """Exclus√µes de vulnerabilidades por diferentes crit√©rios"""
    name = models.CharField(max_length=100)
    description = models.TextField()
    
    # Crit√©rios de exclus√£o
    cve_patterns = models.JSONField(default=list)  # Padr√µes de CVE
    host_patterns = models.JSONField(default=list)  # Padr√µes de host
    port_ranges = models.JSONField(default=list)   # Ranges de porta
    severity_levels = models.JSONField(default=list)  # Severidades a excluir
    
    # Escopo
    applies_to_organization = models.ForeignKey(
        'clients.Client', 
        on_delete=models.CASCADE,
        null=True,
        blank=True
    )
    applies_to_agents = models.ManyToManyField('agents.Agent', blank=True)
    
    # Configura√ß√µes
    is_active = models.BooleanField(default=True)
    auto_apply = models.BooleanField(default=True)
    expiry_date = models.DateTimeField(null=True, blank=True)
    
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    def __str__(self):
        return self.name
    
    def matches_vulnerability(self, vuln: Vulnerability) -> bool:
        """Verifica se uma vulnerabilidade deve ser exclu√≠da"""
        # Implementar l√≥gica de matching
        pass


class VulnerabilityReport(models.Model):
    """Relat√≥rios de vulnerabilidades"""
    
    REPORT_TYPES = [
        ('executive', 'Executive Summary'),
        ('technical', 'Technical Report'),
        ('compliance', 'Compliance Report'),
        ('trend', 'Trend Analysis'),
        ('custom', 'Custom Report'),
    ]
    
    name = models.CharField(max_length=200)
    report_type = models.CharField(max_length=20, choices=REPORT_TYPES)
    description = models.TextField(blank=True)
    
    # Escopo do relat√≥rio
    organization = models.ForeignKey('clients.Client', on_delete=models.CASCADE)
    agents = models.ManyToManyField('agents.Agent', blank=True)
    scan_date_from = models.DateTimeField()
    scan_date_to = models.DateTimeField()
    
    # Filtros
    severity_filter = models.JSONField(default=list)
    status_filter = models.JSONField(default=list)
    include_fixed = models.BooleanField(default=False)
    
    # Conte√∫do do relat√≥rio
    report_data = models.JSONField(default=dict)
    executive_summary = models.TextField(blank=True)
    recommendations = models.TextField(blank=True)
    
    # Arquivo gerado
    report_file = models.FileField(upload_to='vulnerability_reports/', blank=True)
    file_format = models.CharField(max_length=10, choices=[
        ('pdf', 'PDF'),
        ('html', 'HTML'),
        ('json', 'JSON'),
        ('csv', 'CSV'),
        ('xlsx', 'Excel'),
    ], default='pdf')
    
    # Metadados
    generated_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True)
    generated_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['-generated_at']
    
    def __str__(self):
        return f"{self.name} - {self.get_report_type_display()}"


# ====================================================================
# 2. SERIALIZERS - Django REST Framework
# ====================================================================

from rest_framework import serializers

class VulnerabilityScannerSerializer(serializers.ModelSerializer):
    health_status_display = serializers.CharField(source='get_health_status_display', read_only=True)
    connection_test = serializers.SerializerMethodField()
    
    class Meta:
        model = VulnerabilityScanner
        fields = '__all__'
        extra_kwargs = {
            'api_secret': {'write_only': True},
        }
    
    def get_connection_test(self, obj):
        if self.context.get('include_test'):
            return obj.test_connection()
        return None


class VulnerabilitySerializer(serializers.ModelSerializer):
    age_days = serializers.ReadOnlyField()
    is_overdue = serializers.ReadOnlyField()
    scan_name = serializers.CharField(source='scan.scanner.name', read_only=True)
    agent_hostname = serializers.CharField(source='agent.hostname', read_only=True)
    
    class Meta:
        model = Vulnerability
        fields = '__all__'


class VulnerabilityScanSerializer(serializers.ModelSerializer):
    duration = serializers.ReadOnlyField()
    risk_score = serializers.ReadOnlyField()
    scanner_name = serializers.CharField(source='scanner.name', read_only=True)
    agent_hostname = serializers.CharField(source='agent.hostname', read_only=True)
    vulnerability_count = serializers.SerializerMethodField()
    
    class Meta:
        model = VulnerabilityScan
        fields = '__all__'
    
    def get_vulnerability_count(self, obj):
        return {
            'critical': obj.critical_count,
            'high': obj.high_count,
            'medium': obj.medium_count,
            'low': obj.low_count,
            'info': obj.info_count,
            'total': obj.total_vulnerabilities
        }


# ====================================================================
# 3. VIEWS - Django REST Framework
# ====================================================================

from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django_filters.rest_framework import DjangoFilterBackend
from django.db.models import Q, Count, Avg
from rest_framework.permissions import IsAuthenticated

class VulnerabilityScannerViewSet(viewsets.ModelViewSet):
    queryset = VulnerabilityScanner.objects.all()
    serializer_class = VulnerabilityScannerSerializer
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['scanner_type', 'is_active', 'health_status']
    
    @action(detail=True, methods=['post'])
    def test_connection(self, request, pk=None):
        """Testa conex√£o com o scanner"""
        scanner = self.get_object()
        result = scanner.test_connection()
        
        # Atualizar status de sa√∫de
        scanner.health_status = result['status']
        scanner.last_health_check = timezone.now()
        scanner.save()
        
        return Response(result)
    
    @action(detail=True, methods=['post'])
    def start_scan(self, request, pk=None):
        """Inicia um novo scan"""
        scanner = self.get_object()
        agent_id = request.data.get('agent_id')
        profile_id = request.data.get('profile_id')
        
        if not agent_id:
            return Response(
                {'error': 'agent_id is required'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Criar inst√¢ncia de scan
        scan = VulnerabilityScan.objects.create(
            scanner=scanner,
            agent_id=agent_id,
            profile_id=profile_id,
            triggered_by=request.user,
            trigger_type='manual',
            organization=request.user.organization,  # Assumindo rela√ß√£o
            target_specification=request.data.get('targets', ''),
        )
        
        # Iniciar scan
        success = scan.start_scan()
        
        if success:
            return Response(
                VulnerabilityScanSerializer(scan).data,
                status=status.HTTP_201_CREATED
            )
        else:
            return Response(
                {'error': 'Failed to start scan', 'details': scan.error_messages},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    @action(detail=False, methods=['get'])
    def statistics(self, request):
        """Estat√≠sticas dos scanners"""
        stats = {
            'total_scanners': self.queryset.count(),
            'active_scanners': self.queryset.filter(is_active=True).count(),
            'healthy_scanners': self.queryset.filter(health_status='healthy').count(),
            'scanner_types': list(
                self.queryset.values('scanner_type')
                .annotate(count=Count('id'))
                .order_by('-count')
            ),
            'recent_scans': VulnerabilityScan.objects.filter(
                completed_at__gte=timezone.now() - timedelta(days=7)
            ).count()
        }
        return Response(stats)


class VulnerabilityViewSet(viewsets.ModelViewSet):
    queryset = Vulnerability.objects.select_related('scan', 'agent', 'organization')
    serializer_class = VulnerabilitySerializer
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = [
        'severity', 'status', 'cve_id', 'agent', 'organization',
        'verified', 'exploitable'
    ]
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # Filtro por organiza√ß√£o do usu√°rio
        if hasattr(self.request.user, 'organization'):
            queryset = queryset.filter(organization=self.request.user.organization)
        
        # Filtros adicionais via query params
        severity = self.request.query_params.get('severity')
        if severity:
            queryset = queryset.filter(severity__in=severity.split(','))
        
        age_days = self.request.query_params.get('age_days')
        if age_days:
            cutoff_date = timezone.now() - timedelta(days=int(age_days))
            queryset = queryset.filter(first_seen__gte=cutoff_date)
        
        overdue = self.request.query_params.get('overdue')
        if overdue == 'true':
            queryset = queryset.filter(
                due_date__lt=timezone.now(),
                status='open'
            )
        
        return queryset
    
    @action(detail=True, methods=['post'])
    def update_status(self, request, pk=None):
        """Atualiza status da vulnerabilidade"""
        vulnerability = self.get_object()
        new_status = request.data.get('status')
        notes = request.data.get('notes', '')
        
        if not new_status or new_status not in dict(Vulnerability.STATUS_CHOICES):
            return Response(
                {'error': 'Invalid status'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        vulnerability.set_status(new_status, request.user, notes)
        
        return Response(
            VulnerabilitySerializer(vulnerability).data
        )
    
    @action(detail=False, methods=['get'])
    def dashboard(self, request):
        """Dashboard de vulnerabilidades"""
        queryset = self.get_queryset()
        
        # Estat√≠sticas por severidade
        severity_stats = queryset.values('severity').annotate(
            count=Count('id')
        ).order_by('severity')
        
        # Estat√≠sticas por status
        status_stats = queryset.values('status').annotate(
            count=Count('id')
        ).order_by('status')
        
        # Top 10 CVEs
        top_cves = queryset.exclude(cve_id='').values('cve_id').annotate(
            count=Count('id')
        ).order_by('-count')[:10]
        
        # Agentes mais vulner√°veis
        vulnerable_agents = queryset.values(
            'agent__hostname', 'agent__id'
        ).annotate(
            vuln_count=Count('id'),
            critical_count=Count('id', filter=Q(severity='critical')),
            high_count=Count('id', filter=Q(severity='high'))
        ).order_by('-critical_count', '-high_count')[:10]
        
        # Tend√™ncias (√∫ltimos 30 dias)
        thirty_days_ago = timezone.now() - timedelta(days=30)
        trend_data = []
        for i in range(30):
            date = thirty_days_ago + timedelta(days=i)
            day_count = queryset.filter(
                first_seen__date=date.date()
            ).count()
            trend_data.append({
                'date': date.date(),
                'count': day_count
            })
        
        # M√©tricas de SLA
        overdue_count = queryset.filter(
            due_date__lt=timezone.now(),
            status='open'
        ).count()
        
        return Response({
            'total_vulnerabilities': queryset.count(),
            'open_vulnerabilities': queryset.filter(status='open').count(),
            'overdue_vulnerabilities': overdue_count,
            'severity_distribution': severity_stats,
            'status_distribution': status_stats,
            'top_cves': top_cves,
            'most_vulnerable_agents': vulnerable_agents,
            'trend_data': trend_data,
            'average_cvss': queryset.exclude(
                cvss_score__isnull=True
            ).aggregate(avg_cvss=Avg('cvss_score'))['avg_cvss']
        })
    
    @action(detail=False, methods=['post'])
    def bulk_update(self, request):
        """Atualiza√ß√£o em lote de vulnerabilidades"""
        vuln_ids = request.data.get('vulnerability_ids', [])
        action_type = request.data.get('action')
        new_status = request.data.get('status')
        notes = request.data.get('notes', '')
        
        if not vuln_ids or not action_type:
            return Response(
                {'error': 'vulnerability_ids and action are required'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        queryset = self.get_queryset().filter(id__in=vuln_ids)
        
        if action_type == 'update_status' and new_status:
            updated_count = 0
            for vuln in queryset:
                vuln.set_status(new_status, request.user, notes)
                updated_count += 1
            
            return Response({
                'message': f'Updated {updated_count} vulnerabilities',
                'updated_count': updated_count
            })
        
        return Response(
            {'error': 'Invalid action'}, 
            status=status.HTTP_400_BAD_REQUEST
        )


# ====================================================================
# 4. INTEGRA√á√ÉO COM SCANNERS
# ====================================================================

class NessusIntegration:
    """Integra√ß√£o espec√≠fica com Tenable Nessus"""
    
    def __init__(self, scanner: VulnerabilityScanner):
        self.scanner = scanner
        self.base_url = scanner.api_url.rstrip('/')
        self.headers = {
            'X-ApiKeys': f'accessKey={scanner.api_key}; secretKey={scanner.api_secret}',
            'Content-Type': 'application/json'
        }
    
    def create_scan(self, profile: VulnerabilityScanProfile, targets: str) -> Dict:
        """Cria um novo scan no Nessus"""
        scan_data = {
            'uuid': profile.scanner_config.get('template_uuid'),
            'settings': {
                'name': f"m.RMM Scan - {targets}",
                'text_targets': targets,
                'scanner_id': profile.scanner_config.get('scanner_id', '1'),
                'enabled': True,
                'launch': 'ONETIME',
                'folder_id': profile.scanner_config.get('folder_id', '0'),
                'policy_id': profile.scanner_config.get('policy_id'),
            }
        }
        
        response = requests.post(
            f"{self.base_url}/scans",
            headers=self.headers,
            json=scan_data,
            verify=self.scanner.use_ssl_verification
        )
        
        if response.status_code == 200:
            return response.json()
        else:
            raise Exception(f"Failed to create scan: {response.text}")
    
    def launch_scan(self, scan_id: str) -> Dict:
        """Inicia um scan no Nessus"""
        response = requests.post(
            f"{self.base_url}/scans/{scan_id}/launch",
            headers=self.headers,
            verify=self.scanner.use_ssl_verification
        )
        
        if response.status_code == 200:
            return response.json()
        else:
            raise Exception(f"Failed to launch scan: {response.text}")
    
    def get_scan_status(self, scan_id: str) -> Dict:
        """Obt√©m status de um scan"""
        response = requests.get(
            f"{self.base_url}/scans/{scan_id}",
            headers=self.headers,
            verify=self.scanner.use_ssl_verification
        )
        
        if response.status_code == 200:
            return response.json()
        else:
            raise Exception(f"Failed to get scan status: {response.text}")
    
    def get_scan_results(self, scan_id: str) -> List[Dict]:
        """Obt√©m resultados de um scan"""
        # Exportar resultados
        export_data = {
            'format': 'json',
            'chapters': 'vuln_hosts_summary'
        }
        
        export_response = requests.post(
            f"{self.base_url}/scans/{scan_id}/export",
            headers=self.headers,
            json=export_data,
            verify=self.scanner.use_ssl_verification
        )
        
        if export_response.status_code != 200:
            raise Exception("Failed to export scan results")
        
        export_id = export_response.json()['token']
        
        # Aguardar conclus√£o da exporta√ß√£o
        import time
        while True:
            status_response = requests.get(
                f"{self.base_url}/scans/{scan_id}/export/{export_id}/status",
                headers=self.headers,
                verify=self.scanner.use_ssl_verification
            )
            
            if status_response.json()['status'] == 'ready':
                break
            
            time.sleep(5)
        
        # Baixar resultados
        download_response = requests.get(
            f"{self.base_url}/scans/{scan_id}/export/{export_id}/download",
            headers=self.headers,
            verify=self.scanner.use_ssl_verification
        )
        
        return download_response.json()
    
    def parse_vulnerabilities(self, scan_results: Dict, scan: VulnerabilityScan) -> List[Vulnerability]:
        """Converte resultados do Nessus em objetos Vulnerability"""
        vulnerabilities = []
        
        for host in scan_results.get('hosts', []):
            for vuln in host.get('vulnerabilities', []):
                vulnerability = Vulnerability(
                    scan=scan,
                    agent=scan.agent,
                    organization=scan.organization,
                    plugin_id=str(vuln.get('plugin_id')),
                    title=vuln.get('plugin_name', ''),
                    description=vuln.get('description', ''),
                    severity=self._map_nessus_severity(vuln.get('severity')),
                    cvss_score=vuln.get('cvss_base_score'),
                    cve_id=vuln.get('cve', ''),
                    host=host.get('hostname'),
                    port=vuln.get('port'),
                    protocol=vuln.get('protocol'),
                    solution=vuln.get('solution', ''),
                    affected_software=vuln.get('plugin_family', ''),
                    evidence=vuln.get('plugin_output', ''),
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _map_nessus_severity(self, nessus_severity: int) -> str:
        """Mapeia severidade do Nessus para m.RMM"""
        mapping = {
            0: 'info',
            1: 'low',
            2: 'medium',
            3: 'high',
            4: 'critical'
        }
        return mapping.get(nessus_severity, 'info')


# ====================================================================
# 5. TASKS CELERY
# ====================================================================

from celery import shared_task
from django.utils import timezone
from datetime import timedelta

@shared_task
def process_scan_results(scan_id: int):
    """Processa resultados de um scan conclu√≠do"""
    try:
        scan = VulnerabilityScan.objects.get(id=scan_id)
        
        if scan.scanner.scanner_type == 'nessus':
            integration = NessusIntegration(scan.scanner)
            results = integration.get_scan_results(scan.external_scan_id)
            vulnerabilities = integration.parse_vulnerabilities(results, scan)
            
            # Salvar vulnerabilidades
            Vulnerability.objects.bulk_create(vulnerabilities)
            
            # Atualizar contadores do scan
            scan.total_vulnerabilities = len(vulnerabilities)
            scan.critical_count = sum(1 for v in vulnerabilities if v.severity == 'critical')
            scan.high_count = sum(1 for v in vulnerabilities if v.severity == 'high')
            scan.medium_count = sum(1 for v in vulnerabilities if v.severity == 'medium')
            scan.low_count = sum(1 for v in vulnerabilities if v.severity == 'low')
            scan.info_count = sum(1 for v in vulnerabilities if v.severity == 'info')
            
            scan.status = 'completed'
            scan.completed_at = timezone.now()
            scan.save()
            
            # Enviar notifica√ß√µes se necess√°rio
            send_scan_completion_notification.delay(scan_id)
            
    except Exception as e:
        scan.status = 'failed'
        scan.error_messages = str(e)
        scan.save()


@shared_task
def monitor_running_scans():
    """Monitora scans em execu√ß√£o"""
    running_scans = VulnerabilityScan.objects.filter(
        status__in=['running', 'initializing']
    )
    
    for scan in running_scans:
        try:
            if scan.scanner.scanner_type == 'nessus':
                integration = NessusIntegration(scan.scanner)
                status_data = integration.get_scan_status(scan.external_scan_id)
                
                nessus_status = status_data.get('info', {}).get('status')
                
                if nessus_status == 'completed':
                    process_scan_results.delay(scan.id)
                elif nessus_status == 'canceled':
                    scan.status = 'cancelled'
                    scan.save()
                elif nessus_status == 'running':
                    # Atualizar progresso se dispon√≠vel
                    progress = status_data.get('info', {}).get('scanner_progress')
                    if progress:
                        scan.progress_percentage = int(progress)
                        scan.save()
                        
        except Exception as e:
            # Log error but continue with other scans
            print(f"Error monitoring scan {scan.id}: {e}")


@shared_task
def schedule_automatic_scans():
    """Agenda scans autom√°ticos baseados na configura√ß√£o"""
    scanners = VulnerabilityScanner.objects.filter(
        is_active=True,
        auto_start_scans=True
    )
    
    for scanner in scanners:
        # Verificar agentes que precisam de scan
        from agents.models import Agent
        
        cutoff_time = timezone.now() - timedelta(seconds=scanner.default_scan_interval)
        
        agents_needing_scan = Agent.objects.filter(
            organization__in=scanner.allowed_organizations.all(),
            last_scan_date__lt=cutoff_time
        ) | Agent.objects.filter(last_scan_date__isnull=True)
        
        for agent in agents_needing_scan:
            # Verificar se n√£o h√° scan em andamento
            if not VulnerabilityScan.objects.filter(
                agent=agent,
                scanner=scanner,
                status__in=['queued', 'running', 'initializing']
            ).exists():
                
                # Criar novo scan
                scan = VulnerabilityScan.objects.create(
                    scanner=scanner,
                    agent=agent,
                    organization=agent.organization,
                    trigger_type='scheduled',
                    target_specification=agent.public_ip or agent.private_ip,
                )
                
                # Iniciar scan
                scan.start_scan()


@shared_task
def send_scan_completion_notification(scan_id: int):
    """Envia notifica√ß√£o de conclus√£o de scan"""
    try:
        scan = VulnerabilityScan.objects.get(id=scan_id)
        
        # Preparar dados da notifica√ß√£o
        critical_count = scan.critical_count
        high_count = scan.high_count
        
        if critical_count > 0 or high_count > 0:
            # Enviar alerta para administradores
            from alerts.models import Alert
            
            Alert.objects.create(
                alert_type='vulnerability_scan_high_risk',
                severity='high' if critical_count > 0 else 'medium',
                message=f"Vulnerability scan completed on {scan.agent.hostname} with {critical_count} critical and {high_count} high severity vulnerabilities",
                details={
                    'scan_id': scan.id,
                    'agent': scan.agent.hostname,
                    'critical_count': critical_count,
                    'high_count': high_count,
                    'total_vulnerabilities': scan.total_vulnerabilities
                }
            )
            
    except Exception as e:
        print(f"Error sending notification for scan {scan_id}: {e}")


@shared_task
def cleanup_old_scans():
    """Remove scans antigos para manter performance"""
    cutoff_date = timezone.now() - timedelta(days=90)  # Manter 90 dias
    
    old_scans = VulnerabilityScan.objects.filter(
        completed_at__lt=cutoff_date,
        status__in=['completed', 'failed', 'cancelled']
    )
    
    deleted_count = 0
    for scan in old_scans:
        # Manter estat√≠sticas mas remover detalhes
        scan.vulnerabilities.all().delete()
        scan.scan_logs = ""
        scan.debug_info = {}
        scan.save()
        deleted_count += 1
    
    return f"Cleaned up {deleted_count} old scans"


# ====================================================================
# 6. URLS - API Endpoints
# ====================================================================

from django.urls import path, include
from rest_framework.routers import DefaultRouter

router = DefaultRouter()
router.register(r'scanners', VulnerabilityScannerViewSet)
router.register(r'vulnerabilities', VulnerabilityViewSet)
router.register(r'scans', VulnerabilityScanViewSet)

urlpatterns = [
    path('api/v1/vulnerability/', include(router.urls)),
]


# ====================================================================
# 7. ADMIN INTERFACE
# ====================================================================

from django.contrib import admin

@admin.register(VulnerabilityScanner)
class VulnerabilityScannerAdmin(admin.ModelAdmin):
    list_display = ['name', 'scanner_type', 'is_active', 'health_status', 'last_health_check']
    list_filter = ['scanner_type', 'is_active', 'health_status']
    search_fields = ['name', 'api_url']
    readonly_fields = ['last_health_check', 'health_status']
    
    actions = ['test_connections']
    
    def test_connections(self, request, queryset):
        for scanner in queryset:
            scanner.test_connection()
        self.message_user(request, f"Tested {queryset.count()} scanners")
    test_connections.short_description = "Test connections for selected scanners"


@admin.register(Vulnerability)
class VulnerabilityAdmin(admin.ModelAdmin):
    list_display = ['cve_id', 'title', 'severity', 'status', 'agent', 'first_seen', 'age_days']
    list_filter = ['severity', 'status', 'verified', 'exploitable', 'scan__scanner']
    search_fields = ['cve_id', 'title', 'description', 'agent__hostname']
    readonly_fields = ['first_seen', 'last_seen', 'age_days']
    
    actions = ['mark_as_fixed', 'mark_as_false_positive']
    
    def mark_as_fixed(self, request, queryset):
        for vuln in queryset:
            vuln.set_status('fixed', request.user, 'Bulk action from admin')
        self.message_user(request, f"Marked {queryset.count()} vulnerabilities as fixed")
    
    def mark_as_false_positive(self, request, queryset):
        for vuln in queryset:
            vuln.set_status('false_positive', request.user, 'Bulk action from admin')
        self.message_user(request, f"Marked {queryset.count()} vulnerabilities as false positive")


if __name__ == "__main__":
    print("""
    üõ°Ô∏è M√ìDULO DE VULNERABILIDADES m.RMM - IMPLEMENTA√á√ÉO COMPLETA
    
    Este m√≥dulo fornece:
    ‚úÖ Modelos Django avan√ßados para vulnerability management
    ‚úÖ Integra√ß√£o com m√∫ltiplos scanners (Nessus, OpenVAS, etc.)
    ‚úÖ APIs REST completas com filtros avan√ßados
    ‚úÖ Tasks Celery para processamento ass√≠ncrono
    ‚úÖ Dashboard de vulnerabilidades com m√©tricas
    ‚úÖ Sistema de relat√≥rios executivos
    ‚úÖ Workflow de lifecycle das vulnerabilidades
    ‚úÖ SLA tracking e alertas autom√°ticos
    
    Para implementar:
    1. Adicionar ao INSTALLED_APPS do Django
    2. Executar migra√ß√µes
    3. Configurar scanners via admin
    4. Configurar tasks Celery
    5. Integrar com frontend Vue.js
    """)